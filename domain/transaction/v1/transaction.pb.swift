// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: transaction/v1/transaction.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// factories/SecurityTokenFactory.sol 
struct Transaction_V1_Transaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Transaction_V1_Transaction.Metadata {
    get {return _metadata ?? Transaction_V1_Transaction.Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var contract: String = String()

  var network: UInt32 = 0

  var data: Transaction_V1_Transaction.OneOf_Data? = nil

  var deployNewSecurityToken: Transaction_V1_Transaction.SecurityTokenFactory.DeployNewSecurityToken {
    get {
      if case .deployNewSecurityToken(let v)? = data {return v}
      return Transaction_V1_Transaction.SecurityTokenFactory.DeployNewSecurityToken()
    }
    set {data = .deployNewSecurityToken(newValue)}
  }

  var bulkIssueByPartition: Transaction_V1_Transaction.SecurityToken.BulkIssueByPartition {
    get {
      if case .bulkIssueByPartition(let v)? = data {return v}
      return Transaction_V1_Transaction.SecurityToken.BulkIssueByPartition()
    }
    set {data = .bulkIssueByPartition(newValue)}
  }

  var setDocument: Transaction_V1_Transaction.SecurityToken.SetDocument {
    get {
      if case .setDocument(let v)? = data {return v}
      return Transaction_V1_Transaction.SecurityToken.SetDocument()
    }
    set {data = .setDocument(newValue)}
  }

  var issueByPartition: Transaction_V1_Transaction.SecurityToken.IssueByPartition {
    get {
      if case .issueByPartition(let v)? = data {return v}
      return Transaction_V1_Transaction.SecurityToken.IssueByPartition()
    }
    set {data = .issueByPartition(newValue)}
  }

  var redeemByPartition: Transaction_V1_Transaction.SecurityToken.RedeemByPartition {
    get {
      if case .redeemByPartition(let v)? = data {return v}
      return Transaction_V1_Transaction.SecurityToken.RedeemByPartition()
    }
    set {data = .redeemByPartition(newValue)}
  }

  var operatorRedeemByPartition: Transaction_V1_Transaction.SecurityToken.OperatorRedeemByPartition {
    get {
      if case .operatorRedeemByPartition(let v)? = data {return v}
      return Transaction_V1_Transaction.SecurityToken.OperatorRedeemByPartition()
    }
    set {data = .operatorRedeemByPartition(newValue)}
  }

  var renounceControl: Transaction_V1_Transaction.SecurityToken.RenounceControl {
    get {
      if case .renounceControl(let v)? = data {return v}
      return Transaction_V1_Transaction.SecurityToken.RenounceControl()
    }
    set {data = .renounceControl(newValue)}
  }

  var renounceIssuance: Transaction_V1_Transaction.SecurityToken.RenounceIssuance {
    get {
      if case .renounceIssuance(let v)? = data {return v}
      return Transaction_V1_Transaction.SecurityToken.RenounceIssuance()
    }
    set {data = .renounceIssuance(newValue)}
  }

  var pause: Transaction_V1_Transaction.Pausable.Pause {
    get {
      if case .pause(let v)? = data {return v}
      return Transaction_V1_Transaction.Pausable.Pause()
    }
    set {data = .pause(newValue)}
  }

  var unpause: Transaction_V1_Transaction.Pausable.Unpause {
    get {
      if case .unpause(let v)? = data {return v}
      return Transaction_V1_Transaction.Pausable.Unpause()
    }
    set {data = .unpause(newValue)}
  }

  var transferOwnership: Transaction_V1_Transaction.Ownable.TransferOwnership {
    get {
      if case .transferOwnership(let v)? = data {return v}
      return Transaction_V1_Transaction.Ownable.TransferOwnership()
    }
    set {data = .transferOwnership(newValue)}
  }

  var authorizeOperator: Transaction_V1_Transaction.ERC1400Raw.AuthorizeOperator {
    get {
      if case .authorizeOperator(let v)? = data {return v}
      return Transaction_V1_Transaction.ERC1400Raw.AuthorizeOperator()
    }
    set {data = .authorizeOperator(newValue)}
  }

  var revokeOperator: Transaction_V1_Transaction.ERC1400Raw.RevokeOperator {
    get {
      if case .revokeOperator(let v)? = data {return v}
      return Transaction_V1_Transaction.ERC1400Raw.RevokeOperator()
    }
    set {data = .revokeOperator(newValue)}
  }

  var transferByPartition: Transaction_V1_Transaction.ERC1400Partition.TransferByPartition {
    get {
      if case .transferByPartition(let v)? = data {return v}
      return Transaction_V1_Transaction.ERC1400Partition.TransferByPartition()
    }
    set {data = .transferByPartition(newValue)}
  }

  var operatorTransferByPartition: Transaction_V1_Transaction.ERC1400Partition.OperatorTransferByPartition {
    get {
      if case .operatorTransferByPartition(let v)? = data {return v}
      return Transaction_V1_Transaction.ERC1400Partition.OperatorTransferByPartition()
    }
    set {data = .operatorTransferByPartition(newValue)}
  }

  var authorizeOperatorByPartition: Transaction_V1_Transaction.ERC1400Partition.AuthorizeOperatorByPartition {
    get {
      if case .authorizeOperatorByPartition(let v)? = data {return v}
      return Transaction_V1_Transaction.ERC1400Partition.AuthorizeOperatorByPartition()
    }
    set {data = .authorizeOperatorByPartition(newValue)}
  }

  var revokeOperatorByPartition: Transaction_V1_Transaction.ERC1400Partition.RevokeOperatorByPartition {
    get {
      if case .revokeOperatorByPartition(let v)? = data {return v}
      return Transaction_V1_Transaction.ERC1400Partition.RevokeOperatorByPartition()
    }
    set {data = .revokeOperatorByPartition(newValue)}
  }

  var transferWithData: Transaction_V1_Transaction.ERC1400Partition.TransferWithData {
    get {
      if case .transferWithData(let v)? = data {return v}
      return Transaction_V1_Transaction.ERC1400Partition.TransferWithData()
    }
    set {data = .transferWithData(newValue)}
  }

  var transferFromWithData: Transaction_V1_Transaction.ERC1400Partition.TransferFromWithData {
    get {
      if case .transferFromWithData(let v)? = data {return v}
      return Transaction_V1_Transaction.ERC1400Partition.TransferFromWithData()
    }
    set {data = .transferFromWithData(newValue)}
  }

  var transfer: Transaction_V1_Transaction.ERC1400ERC20.Transfer {
    get {
      if case .transfer(let v)? = data {return v}
      return Transaction_V1_Transaction.ERC1400ERC20.Transfer()
    }
    set {data = .transfer(newValue)}
  }

  var approve: Transaction_V1_Transaction.ERC1400ERC20.Approve {
    get {
      if case .approve(let v)? = data {return v}
      return Transaction_V1_Transaction.ERC1400ERC20.Approve()
    }
    set {data = .approve(newValue)}
  }

  var transferFrom: Transaction_V1_Transaction.ERC1400ERC20.TransferFrom {
    get {
      if case .transferFrom(let v)? = data {return v}
      return Transaction_V1_Transaction.ERC1400ERC20.TransferFrom()
    }
    set {data = .transferFrom(newValue)}
  }

  var setCap: Transaction_V1_Transaction.ERC1400Capped.SetCap {
    get {
      if case .setCap(let v)? = data {return v}
      return Transaction_V1_Transaction.ERC1400Capped.SetCap()
    }
    set {data = .setCap(newValue)}
  }

  var setModulesByPartition: Transaction_V1_Transaction.Constrainable.SetModulesByPartition {
    get {
      if case .setModulesByPartition(let v)? = data {return v}
      return Transaction_V1_Transaction.Constrainable.SetModulesByPartition()
    }
    set {data = .setModulesByPartition(newValue)}
  }

  var addRole: Transaction_V1_Transaction.Administrable.AddRole {
    get {
      if case .addRole(let v)? = data {return v}
      return Transaction_V1_Transaction.Administrable.AddRole()
    }
    set {data = .addRole(newValue)}
  }

  var bulkAddRole: Transaction_V1_Transaction.Administrable.BulkAddRole {
    get {
      if case .bulkAddRole(let v)? = data {return v}
      return Transaction_V1_Transaction.Administrable.BulkAddRole()
    }
    set {data = .bulkAddRole(newValue)}
  }

  var removeRole: Transaction_V1_Transaction.Administrable.RemoveRole {
    get {
      if case .removeRole(let v)? = data {return v}
      return Transaction_V1_Transaction.Administrable.RemoveRole()
    }
    set {data = .removeRole(newValue)}
  }

  var renounceRole: Transaction_V1_Transaction.Administrable.RenounceRole {
    get {
      if case .renounceRole(let v)? = data {return v}
      return Transaction_V1_Transaction.Administrable.RenounceRole()
    }
    set {data = .renounceRole(newValue)}
  }

  var deploySpendingLimitsConstraintModule: Transaction_V1_Transaction.SpendingLimitsConstraintModule.DeploySpendingLimitsConstraintModule {
    get {
      if case .deploySpendingLimitsConstraintModule(let v)? = data {return v}
      return Transaction_V1_Transaction.SpendingLimitsConstraintModule.DeploySpendingLimitsConstraintModule()
    }
    set {data = .deploySpendingLimitsConstraintModule(newValue)}
  }

  var addTimelock: Transaction_V1_Transaction.SpendingLimitsConstraintModule.AddTimelock {
    get {
      if case .addTimelock(let v)? = data {return v}
      return Transaction_V1_Transaction.SpendingLimitsConstraintModule.AddTimelock()
    }
    set {data = .addTimelock(newValue)}
  }

  var setTimelock: Transaction_V1_Transaction.SpendingLimitsConstraintModule.SetTimelock {
    get {
      if case .setTimelock(let v)? = data {return v}
      return Transaction_V1_Transaction.SpendingLimitsConstraintModule.SetTimelock()
    }
    set {data = .setTimelock(newValue)}
  }

  var deleteTimelock: Transaction_V1_Transaction.SpendingLimitsConstraintModule.DeleteTimelock {
    get {
      if case .deleteTimelock(let v)? = data {return v}
      return Transaction_V1_Transaction.SpendingLimitsConstraintModule.DeleteTimelock()
    }
    set {data = .deleteTimelock(newValue)}
  }

  var deployTimeLockConstraintModule: Transaction_V1_Transaction.TimeLockConstraintModule.DeployTimeLockConstraintModule {
    get {
      if case .deployTimeLockConstraintModule(let v)? = data {return v}
      return Transaction_V1_Transaction.TimeLockConstraintModule.DeployTimeLockConstraintModule()
    }
    set {data = .deployTimeLockConstraintModule(newValue)}
  }

  var editAmountTimeLock: Transaction_V1_Transaction.TimeLockConstraintModule.EditAmountTimeLock {
    get {
      if case .editAmountTimeLock(let v)? = data {return v}
      return Transaction_V1_Transaction.TimeLockConstraintModule.EditAmountTimeLock()
    }
    set {data = .editAmountTimeLock(newValue)}
  }

  var editAccountTimeLock: Transaction_V1_Transaction.TimeLockConstraintModule.EditAccountTimeLock {
    get {
      if case .editAccountTimeLock(let v)? = data {return v}
      return Transaction_V1_Transaction.TimeLockConstraintModule.EditAccountTimeLock()
    }
    set {data = .editAccountTimeLock(newValue)}
  }

  var editTimeLock: Transaction_V1_Transaction.TimeLockConstraintModule.EditTimeLock {
    get {
      if case .editTimeLock(let v)? = data {return v}
      return Transaction_V1_Transaction.TimeLockConstraintModule.EditTimeLock()
    }
    set {data = .editTimeLock(newValue)}
  }

  var deployVestingPeriodConstraintModule: Transaction_V1_Transaction.VestingPeriodConstraintModule.DeployVestingPeriodConstraintModule {
    get {
      if case .deployVestingPeriodConstraintModule(let v)? = data {return v}
      return Transaction_V1_Transaction.VestingPeriodConstraintModule.DeployVestingPeriodConstraintModule()
    }
    set {data = .deployVestingPeriodConstraintModule(newValue)}
  }

  var setVestingOptions: Transaction_V1_Transaction.VestingPeriodConstraintModule.SetVestingOptions {
    get {
      if case .setVestingOptions(let v)? = data {return v}
      return Transaction_V1_Transaction.VestingPeriodConstraintModule.SetVestingOptions()
    }
    set {data = .setVestingOptions(newValue)}
  }

  var deployWhitelistConstraintModule: Transaction_V1_Transaction.WhitelistConstraintModule.DeployWhitelistConstraintModule {
    get {
      if case .deployWhitelistConstraintModule(let v)? = data {return v}
      return Transaction_V1_Transaction.WhitelistConstraintModule.DeployWhitelistConstraintModule()
    }
    set {data = .deployWhitelistConstraintModule(newValue)}
  }

  var editWhitelist: Transaction_V1_Transaction.WhitelistConstraintModule.EditWhitelist {
    get {
      if case .editWhitelist(let v)? = data {return v}
      return Transaction_V1_Transaction.WhitelistConstraintModule.EditWhitelist()
    }
    set {data = .editWhitelist(newValue)}
  }

  var bulkEditWhitelist: Transaction_V1_Transaction.WhitelistConstraintModule.BulkEditWhitelist {
    get {
      if case .bulkEditWhitelist(let v)? = data {return v}
      return Transaction_V1_Transaction.WhitelistConstraintModule.BulkEditWhitelist()
    }
    set {data = .bulkEditWhitelist(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Data: Equatable {
    case deployNewSecurityToken(Transaction_V1_Transaction.SecurityTokenFactory.DeployNewSecurityToken)
    case bulkIssueByPartition(Transaction_V1_Transaction.SecurityToken.BulkIssueByPartition)
    case setDocument(Transaction_V1_Transaction.SecurityToken.SetDocument)
    case issueByPartition(Transaction_V1_Transaction.SecurityToken.IssueByPartition)
    case redeemByPartition(Transaction_V1_Transaction.SecurityToken.RedeemByPartition)
    case operatorRedeemByPartition(Transaction_V1_Transaction.SecurityToken.OperatorRedeemByPartition)
    case renounceControl(Transaction_V1_Transaction.SecurityToken.RenounceControl)
    case renounceIssuance(Transaction_V1_Transaction.SecurityToken.RenounceIssuance)
    case pause(Transaction_V1_Transaction.Pausable.Pause)
    case unpause(Transaction_V1_Transaction.Pausable.Unpause)
    case transferOwnership(Transaction_V1_Transaction.Ownable.TransferOwnership)
    case authorizeOperator(Transaction_V1_Transaction.ERC1400Raw.AuthorizeOperator)
    case revokeOperator(Transaction_V1_Transaction.ERC1400Raw.RevokeOperator)
    case transferByPartition(Transaction_V1_Transaction.ERC1400Partition.TransferByPartition)
    case operatorTransferByPartition(Transaction_V1_Transaction.ERC1400Partition.OperatorTransferByPartition)
    case authorizeOperatorByPartition(Transaction_V1_Transaction.ERC1400Partition.AuthorizeOperatorByPartition)
    case revokeOperatorByPartition(Transaction_V1_Transaction.ERC1400Partition.RevokeOperatorByPartition)
    case transferWithData(Transaction_V1_Transaction.ERC1400Partition.TransferWithData)
    case transferFromWithData(Transaction_V1_Transaction.ERC1400Partition.TransferFromWithData)
    case transfer(Transaction_V1_Transaction.ERC1400ERC20.Transfer)
    case approve(Transaction_V1_Transaction.ERC1400ERC20.Approve)
    case transferFrom(Transaction_V1_Transaction.ERC1400ERC20.TransferFrom)
    case setCap(Transaction_V1_Transaction.ERC1400Capped.SetCap)
    case setModulesByPartition(Transaction_V1_Transaction.Constrainable.SetModulesByPartition)
    case addRole(Transaction_V1_Transaction.Administrable.AddRole)
    case bulkAddRole(Transaction_V1_Transaction.Administrable.BulkAddRole)
    case removeRole(Transaction_V1_Transaction.Administrable.RemoveRole)
    case renounceRole(Transaction_V1_Transaction.Administrable.RenounceRole)
    case deploySpendingLimitsConstraintModule(Transaction_V1_Transaction.SpendingLimitsConstraintModule.DeploySpendingLimitsConstraintModule)
    case addTimelock(Transaction_V1_Transaction.SpendingLimitsConstraintModule.AddTimelock)
    case setTimelock(Transaction_V1_Transaction.SpendingLimitsConstraintModule.SetTimelock)
    case deleteTimelock(Transaction_V1_Transaction.SpendingLimitsConstraintModule.DeleteTimelock)
    case deployTimeLockConstraintModule(Transaction_V1_Transaction.TimeLockConstraintModule.DeployTimeLockConstraintModule)
    case editAmountTimeLock(Transaction_V1_Transaction.TimeLockConstraintModule.EditAmountTimeLock)
    case editAccountTimeLock(Transaction_V1_Transaction.TimeLockConstraintModule.EditAccountTimeLock)
    case editTimeLock(Transaction_V1_Transaction.TimeLockConstraintModule.EditTimeLock)
    case deployVestingPeriodConstraintModule(Transaction_V1_Transaction.VestingPeriodConstraintModule.DeployVestingPeriodConstraintModule)
    case setVestingOptions(Transaction_V1_Transaction.VestingPeriodConstraintModule.SetVestingOptions)
    case deployWhitelistConstraintModule(Transaction_V1_Transaction.WhitelistConstraintModule.DeployWhitelistConstraintModule)
    case editWhitelist(Transaction_V1_Transaction.WhitelistConstraintModule.EditWhitelist)
    case bulkEditWhitelist(Transaction_V1_Transaction.WhitelistConstraintModule.BulkEditWhitelist)

  #if !swift(>=4.1)
    static func ==(lhs: Transaction_V1_Transaction.OneOf_Data, rhs: Transaction_V1_Transaction.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.deployNewSecurityToken, .deployNewSecurityToken): return {
        guard case .deployNewSecurityToken(let l) = lhs, case .deployNewSecurityToken(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bulkIssueByPartition, .bulkIssueByPartition): return {
        guard case .bulkIssueByPartition(let l) = lhs, case .bulkIssueByPartition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setDocument, .setDocument): return {
        guard case .setDocument(let l) = lhs, case .setDocument(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.issueByPartition, .issueByPartition): return {
        guard case .issueByPartition(let l) = lhs, case .issueByPartition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.redeemByPartition, .redeemByPartition): return {
        guard case .redeemByPartition(let l) = lhs, case .redeemByPartition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.operatorRedeemByPartition, .operatorRedeemByPartition): return {
        guard case .operatorRedeemByPartition(let l) = lhs, case .operatorRedeemByPartition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.renounceControl, .renounceControl): return {
        guard case .renounceControl(let l) = lhs, case .renounceControl(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.renounceIssuance, .renounceIssuance): return {
        guard case .renounceIssuance(let l) = lhs, case .renounceIssuance(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pause, .pause): return {
        guard case .pause(let l) = lhs, case .pause(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unpause, .unpause): return {
        guard case .unpause(let l) = lhs, case .unpause(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.transferOwnership, .transferOwnership): return {
        guard case .transferOwnership(let l) = lhs, case .transferOwnership(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.authorizeOperator, .authorizeOperator): return {
        guard case .authorizeOperator(let l) = lhs, case .authorizeOperator(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.revokeOperator, .revokeOperator): return {
        guard case .revokeOperator(let l) = lhs, case .revokeOperator(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.transferByPartition, .transferByPartition): return {
        guard case .transferByPartition(let l) = lhs, case .transferByPartition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.operatorTransferByPartition, .operatorTransferByPartition): return {
        guard case .operatorTransferByPartition(let l) = lhs, case .operatorTransferByPartition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.authorizeOperatorByPartition, .authorizeOperatorByPartition): return {
        guard case .authorizeOperatorByPartition(let l) = lhs, case .authorizeOperatorByPartition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.revokeOperatorByPartition, .revokeOperatorByPartition): return {
        guard case .revokeOperatorByPartition(let l) = lhs, case .revokeOperatorByPartition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.transferWithData, .transferWithData): return {
        guard case .transferWithData(let l) = lhs, case .transferWithData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.transferFromWithData, .transferFromWithData): return {
        guard case .transferFromWithData(let l) = lhs, case .transferFromWithData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.transfer, .transfer): return {
        guard case .transfer(let l) = lhs, case .transfer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.approve, .approve): return {
        guard case .approve(let l) = lhs, case .approve(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.transferFrom, .transferFrom): return {
        guard case .transferFrom(let l) = lhs, case .transferFrom(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setCap, .setCap): return {
        guard case .setCap(let l) = lhs, case .setCap(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setModulesByPartition, .setModulesByPartition): return {
        guard case .setModulesByPartition(let l) = lhs, case .setModulesByPartition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.addRole, .addRole): return {
        guard case .addRole(let l) = lhs, case .addRole(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bulkAddRole, .bulkAddRole): return {
        guard case .bulkAddRole(let l) = lhs, case .bulkAddRole(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.removeRole, .removeRole): return {
        guard case .removeRole(let l) = lhs, case .removeRole(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.renounceRole, .renounceRole): return {
        guard case .renounceRole(let l) = lhs, case .renounceRole(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deploySpendingLimitsConstraintModule, .deploySpendingLimitsConstraintModule): return {
        guard case .deploySpendingLimitsConstraintModule(let l) = lhs, case .deploySpendingLimitsConstraintModule(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.addTimelock, .addTimelock): return {
        guard case .addTimelock(let l) = lhs, case .addTimelock(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setTimelock, .setTimelock): return {
        guard case .setTimelock(let l) = lhs, case .setTimelock(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deleteTimelock, .deleteTimelock): return {
        guard case .deleteTimelock(let l) = lhs, case .deleteTimelock(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deployTimeLockConstraintModule, .deployTimeLockConstraintModule): return {
        guard case .deployTimeLockConstraintModule(let l) = lhs, case .deployTimeLockConstraintModule(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.editAmountTimeLock, .editAmountTimeLock): return {
        guard case .editAmountTimeLock(let l) = lhs, case .editAmountTimeLock(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.editAccountTimeLock, .editAccountTimeLock): return {
        guard case .editAccountTimeLock(let l) = lhs, case .editAccountTimeLock(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.editTimeLock, .editTimeLock): return {
        guard case .editTimeLock(let l) = lhs, case .editTimeLock(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deployVestingPeriodConstraintModule, .deployVestingPeriodConstraintModule): return {
        guard case .deployVestingPeriodConstraintModule(let l) = lhs, case .deployVestingPeriodConstraintModule(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setVestingOptions, .setVestingOptions): return {
        guard case .setVestingOptions(let l) = lhs, case .setVestingOptions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deployWhitelistConstraintModule, .deployWhitelistConstraintModule): return {
        guard case .deployWhitelistConstraintModule(let l) = lhs, case .deployWhitelistConstraintModule(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.editWhitelist, .editWhitelist): return {
        guard case .editWhitelist(let l) = lhs, case .editWhitelist(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bulkEditWhitelist, .bulkEditWhitelist): return {
        guard case .bulkEditWhitelist(let l) = lhs, case .bulkEditWhitelist(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct SecurityTokenFactory {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct DeployNewSecurityToken {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var name: String = String()

      var symbol: String = String()

      var granularity: UInt64 = 0

      var cap: UInt64 = 0

      var admin: String = String()

      var controller: String = String()

      var issuer: String = String()

      var redeemer: String = String()

      var moduleEditor: String = String()

      var metadata: Token_V1_SecurityToken.Metadata {
        get {return _metadata ?? Token_V1_SecurityToken.Metadata()}
        set {_metadata = newValue}
      }
      /// Returns true if `metadata` has been explicitly set.
      var hasMetadata: Bool {return self._metadata != nil}
      /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
      mutating func clearMetadata() {self._metadata = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _metadata: Token_V1_SecurityToken.Metadata? = nil
    }

    init() {}
  }

  struct SecurityToken {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct BulkIssueByPartition {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var partition: Data = Data()

      var tokenHolders: [String] = []

      var values: [UInt64] = []

      var data: Data = Data()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct SetDocument {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var documentName: Data = Data()

      var uri: String = String()

      var documentHash: Data = Data()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct IssueByPartition {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var partition: Data = Data()

      var recipient: String = String()

      var amount: UInt64 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct RedeemByPartition {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var partition: Data = Data()

      var value: UInt64 = 0

      var data: Data = Data()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct OperatorRedeemByPartition {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var partition: Data = Data()

      var tokenHolder: String = String()

      var value: UInt64 = 0

      var data: Data = Data()

      var operatorData: Data = Data()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct RenounceControl {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct RenounceIssuance {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  struct Pausable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Pause {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Unpause {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  struct Ownable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct TransferOwnership {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var newOwner: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  struct ERC1400Raw {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct AuthorizeOperator {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var `operator`: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct RevokeOperator {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var `operator`: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  struct ERC1400Partition {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct TransferByPartition {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var partition: Data = Data()

      var to: String = String()

      var value: UInt64 = 0

      var calldata: Data = Data()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct OperatorTransferByPartition {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var partition: Data = Data()

      var from: String = String()

      var to: String = String()

      var value: UInt64 = 0

      var data: Data = Data()

      var operatorData: Data = Data()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct AuthorizeOperatorByPartition {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var partition: Data = Data()

      var `operator`: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct RevokeOperatorByPartition {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var partition: Data = Data()

      var `operator`: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct TransferWithData {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var to: String = String()

      var value: UInt64 = 0

      var data: Data = Data()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct TransferFromWithData {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var from: String = String()

      var to: String = String()

      var value: UInt64 = 0

      var data: Data = Data()

      var operatorData: Data = Data()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  struct ERC1400ERC20 {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Transfer {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var to: String = String()

      var value: UInt64 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Approve {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var spender: String = String()

      var value: UInt64 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct TransferFrom {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var from: String = String()

      var to: String = String()

      var value: UInt64 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  struct ERC1400Capped {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct SetCap {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var newCap: UInt64 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  struct Constrainable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct SetModulesByPartition {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var partition: Data = Data()

      var newModules: [String] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  struct Administrable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct AddRole {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var role: Data = Data()

      var account: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct BulkAddRole {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var roles: [Data] = []

      var accounts: [String] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct RemoveRole {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var role: Data = Data()

      var account: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct RenounceRole {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var role: Data = Data()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  struct SpendingLimitsConstraintModule {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct DeploySpendingLimitsConstraintModule {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var tokenAddress: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct AddTimelock {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var periodLength: SwiftProtobuf.Google_Protobuf_Duration {
        get {return _periodLength ?? SwiftProtobuf.Google_Protobuf_Duration()}
        set {_periodLength = newValue}
      }
      /// Returns true if `periodLength` has been explicitly set.
      var hasPeriodLength: Bool {return self._periodLength != nil}
      /// Clears the value of `periodLength`. Subsequent reads from it will return its default value.
      mutating func clearPeriodLength() {self._periodLength = nil}

      var amountAllowed: UInt64 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _periodLength: SwiftProtobuf.Google_Protobuf_Duration? = nil
    }

    struct SetTimelock {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var index: UInt64 = 0

      var periodLength: SwiftProtobuf.Google_Protobuf_Duration {
        get {return _periodLength ?? SwiftProtobuf.Google_Protobuf_Duration()}
        set {_periodLength = newValue}
      }
      /// Returns true if `periodLength` has been explicitly set.
      var hasPeriodLength: Bool {return self._periodLength != nil}
      /// Clears the value of `periodLength`. Subsequent reads from it will return its default value.
      mutating func clearPeriodLength() {self._periodLength = nil}

      var amountAllowed: UInt64 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _periodLength: SwiftProtobuf.Google_Protobuf_Duration? = nil
    }

    struct DeleteTimelock {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var index: UInt64 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  struct TimeLockConstraintModule {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct DeployTimeLockConstraintModule {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var tokenAddress: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct EditAmountTimeLock {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var account: String = String()

      var time: SwiftProtobuf.Google_Protobuf_Timestamp {
        get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
        set {_time = newValue}
      }
      /// Returns true if `time` has been explicitly set.
      var hasTime: Bool {return self._time != nil}
      /// Clears the value of `time`. Subsequent reads from it will return its default value.
      mutating func clearTime() {self._time = nil}

      var amount: UInt64 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    }

    struct EditAccountTimeLock {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var account: String = String()

      var time: SwiftProtobuf.Google_Protobuf_Timestamp {
        get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
        set {_time = newValue}
      }
      /// Returns true if `time` has been explicitly set.
      var hasTime: Bool {return self._time != nil}
      /// Clears the value of `time`. Subsequent reads from it will return its default value.
      mutating func clearTime() {self._time = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    }

    struct EditTimeLock {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var time: SwiftProtobuf.Google_Protobuf_Timestamp {
        get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
        set {_time = newValue}
      }
      /// Returns true if `time` has been explicitly set.
      var hasTime: Bool {return self._time != nil}
      /// Clears the value of `time`. Subsequent reads from it will return its default value.
      mutating func clearTime() {self._time = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    }

    init() {}
  }

  struct VestingPeriodConstraintModule {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct DeployVestingPeriodConstraintModule {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var tokenAddress: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct SetVestingOptions {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var vestingStart: SwiftProtobuf.Google_Protobuf_Timestamp {
        get {return _vestingStart ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
        set {_vestingStart = newValue}
      }
      /// Returns true if `vestingStart` has been explicitly set.
      var hasVestingStart: Bool {return self._vestingStart != nil}
      /// Clears the value of `vestingStart`. Subsequent reads from it will return its default value.
      mutating func clearVestingStart() {self._vestingStart = nil}

      var vestedFractionAfterStart: UInt64 = 0

      var vestingRatio: UInt64 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _vestingStart: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    }

    init() {}
  }

  struct WhitelistConstraintModule {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct DeployWhitelistConstraintModule {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var tokenAddress: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct EditWhitelist {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var account: String = String()

      var whitelisted: Bool = false

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct BulkEditWhitelist {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var accounts: [String] = []

      var whitelisted: Bool = false

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  /// Metadata 
  struct Metadata {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hash: String = String()

    var date: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_date = newValue}
    }
    /// Returns true if `date` has been explicitly set.
    var hasDate: Bool {return self._date != nil}
    /// Clears the value of `date`. Subsequent reads from it will return its default value.
    mutating func clearDate() {self._date = nil}

    var reverted: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  init() {}

  fileprivate var _metadata: Transaction_V1_Transaction.Metadata? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Transaction_V1_Transaction: @unchecked Sendable {}
extension Transaction_V1_Transaction.OneOf_Data: @unchecked Sendable {}
extension Transaction_V1_Transaction.SecurityTokenFactory: @unchecked Sendable {}
extension Transaction_V1_Transaction.SecurityTokenFactory.DeployNewSecurityToken: @unchecked Sendable {}
extension Transaction_V1_Transaction.SecurityToken: @unchecked Sendable {}
extension Transaction_V1_Transaction.SecurityToken.BulkIssueByPartition: @unchecked Sendable {}
extension Transaction_V1_Transaction.SecurityToken.SetDocument: @unchecked Sendable {}
extension Transaction_V1_Transaction.SecurityToken.IssueByPartition: @unchecked Sendable {}
extension Transaction_V1_Transaction.SecurityToken.RedeemByPartition: @unchecked Sendable {}
extension Transaction_V1_Transaction.SecurityToken.OperatorRedeemByPartition: @unchecked Sendable {}
extension Transaction_V1_Transaction.SecurityToken.RenounceControl: @unchecked Sendable {}
extension Transaction_V1_Transaction.SecurityToken.RenounceIssuance: @unchecked Sendable {}
extension Transaction_V1_Transaction.Pausable: @unchecked Sendable {}
extension Transaction_V1_Transaction.Pausable.Pause: @unchecked Sendable {}
extension Transaction_V1_Transaction.Pausable.Unpause: @unchecked Sendable {}
extension Transaction_V1_Transaction.Ownable: @unchecked Sendable {}
extension Transaction_V1_Transaction.Ownable.TransferOwnership: @unchecked Sendable {}
extension Transaction_V1_Transaction.ERC1400Raw: @unchecked Sendable {}
extension Transaction_V1_Transaction.ERC1400Raw.AuthorizeOperator: @unchecked Sendable {}
extension Transaction_V1_Transaction.ERC1400Raw.RevokeOperator: @unchecked Sendable {}
extension Transaction_V1_Transaction.ERC1400Partition: @unchecked Sendable {}
extension Transaction_V1_Transaction.ERC1400Partition.TransferByPartition: @unchecked Sendable {}
extension Transaction_V1_Transaction.ERC1400Partition.OperatorTransferByPartition: @unchecked Sendable {}
extension Transaction_V1_Transaction.ERC1400Partition.AuthorizeOperatorByPartition: @unchecked Sendable {}
extension Transaction_V1_Transaction.ERC1400Partition.RevokeOperatorByPartition: @unchecked Sendable {}
extension Transaction_V1_Transaction.ERC1400Partition.TransferWithData: @unchecked Sendable {}
extension Transaction_V1_Transaction.ERC1400Partition.TransferFromWithData: @unchecked Sendable {}
extension Transaction_V1_Transaction.ERC1400ERC20: @unchecked Sendable {}
extension Transaction_V1_Transaction.ERC1400ERC20.Transfer: @unchecked Sendable {}
extension Transaction_V1_Transaction.ERC1400ERC20.Approve: @unchecked Sendable {}
extension Transaction_V1_Transaction.ERC1400ERC20.TransferFrom: @unchecked Sendable {}
extension Transaction_V1_Transaction.ERC1400Capped: @unchecked Sendable {}
extension Transaction_V1_Transaction.ERC1400Capped.SetCap: @unchecked Sendable {}
extension Transaction_V1_Transaction.Constrainable: @unchecked Sendable {}
extension Transaction_V1_Transaction.Constrainable.SetModulesByPartition: @unchecked Sendable {}
extension Transaction_V1_Transaction.Administrable: @unchecked Sendable {}
extension Transaction_V1_Transaction.Administrable.AddRole: @unchecked Sendable {}
extension Transaction_V1_Transaction.Administrable.BulkAddRole: @unchecked Sendable {}
extension Transaction_V1_Transaction.Administrable.RemoveRole: @unchecked Sendable {}
extension Transaction_V1_Transaction.Administrable.RenounceRole: @unchecked Sendable {}
extension Transaction_V1_Transaction.SpendingLimitsConstraintModule: @unchecked Sendable {}
extension Transaction_V1_Transaction.SpendingLimitsConstraintModule.DeploySpendingLimitsConstraintModule: @unchecked Sendable {}
extension Transaction_V1_Transaction.SpendingLimitsConstraintModule.AddTimelock: @unchecked Sendable {}
extension Transaction_V1_Transaction.SpendingLimitsConstraintModule.SetTimelock: @unchecked Sendable {}
extension Transaction_V1_Transaction.SpendingLimitsConstraintModule.DeleteTimelock: @unchecked Sendable {}
extension Transaction_V1_Transaction.TimeLockConstraintModule: @unchecked Sendable {}
extension Transaction_V1_Transaction.TimeLockConstraintModule.DeployTimeLockConstraintModule: @unchecked Sendable {}
extension Transaction_V1_Transaction.TimeLockConstraintModule.EditAmountTimeLock: @unchecked Sendable {}
extension Transaction_V1_Transaction.TimeLockConstraintModule.EditAccountTimeLock: @unchecked Sendable {}
extension Transaction_V1_Transaction.TimeLockConstraintModule.EditTimeLock: @unchecked Sendable {}
extension Transaction_V1_Transaction.VestingPeriodConstraintModule: @unchecked Sendable {}
extension Transaction_V1_Transaction.VestingPeriodConstraintModule.DeployVestingPeriodConstraintModule: @unchecked Sendable {}
extension Transaction_V1_Transaction.VestingPeriodConstraintModule.SetVestingOptions: @unchecked Sendable {}
extension Transaction_V1_Transaction.WhitelistConstraintModule: @unchecked Sendable {}
extension Transaction_V1_Transaction.WhitelistConstraintModule.DeployWhitelistConstraintModule: @unchecked Sendable {}
extension Transaction_V1_Transaction.WhitelistConstraintModule.EditWhitelist: @unchecked Sendable {}
extension Transaction_V1_Transaction.WhitelistConstraintModule.BulkEditWhitelist: @unchecked Sendable {}
extension Transaction_V1_Transaction.Metadata: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "transaction.v1"

extension Transaction_V1_Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Transaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "contract"),
    3: .same(proto: "network"),
    4: .standard(proto: "deploy_new_security_token"),
    5: .standard(proto: "bulk_issue_by_partition"),
    6: .standard(proto: "set_document"),
    7: .standard(proto: "issue_by_partition"),
    8: .standard(proto: "redeem_by_partition"),
    9: .standard(proto: "operator_redeem_by_partition"),
    10: .standard(proto: "renounce_control"),
    11: .standard(proto: "renounce_issuance"),
    12: .same(proto: "pause"),
    13: .same(proto: "unpause"),
    14: .standard(proto: "transfer_ownership"),
    15: .standard(proto: "authorize_operator"),
    16: .standard(proto: "revoke_operator"),
    17: .standard(proto: "transfer_by_partition"),
    18: .standard(proto: "operator_transfer_by_partition"),
    19: .standard(proto: "authorize_operator_by_partition"),
    20: .standard(proto: "revoke_operator_by_partition"),
    21: .standard(proto: "transfer_with_data"),
    22: .standard(proto: "transfer_from_with_data"),
    23: .same(proto: "transfer"),
    24: .same(proto: "approve"),
    25: .standard(proto: "transfer_from"),
    26: .standard(proto: "set_cap"),
    27: .standard(proto: "set_modules_by_partition"),
    28: .standard(proto: "add_role"),
    29: .standard(proto: "bulk_add_role"),
    30: .standard(proto: "remove_role"),
    31: .standard(proto: "renounce_role"),
    32: .standard(proto: "deploy_spending_limits_constraint_module"),
    33: .standard(proto: "add_timelock"),
    34: .standard(proto: "set_timelock"),
    35: .standard(proto: "delete_timelock"),
    36: .standard(proto: "deploy_time_lock_constraint_module"),
    37: .standard(proto: "edit_amount_time_lock"),
    38: .standard(proto: "edit_account_time_lock"),
    39: .standard(proto: "edit_time_lock"),
    40: .standard(proto: "deploy_vesting_period_constraint_module"),
    41: .standard(proto: "set_vesting_options"),
    42: .standard(proto: "deploy_whitelist_constraint_module"),
    43: .standard(proto: "edit_whitelist"),
    44: .standard(proto: "bulk_edit_whitelist"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.contract) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.network) }()
      case 4: try {
        var v: Transaction_V1_Transaction.SecurityTokenFactory.DeployNewSecurityToken?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .deployNewSecurityToken(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .deployNewSecurityToken(v)
        }
      }()
      case 5: try {
        var v: Transaction_V1_Transaction.SecurityToken.BulkIssueByPartition?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .bulkIssueByPartition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .bulkIssueByPartition(v)
        }
      }()
      case 6: try {
        var v: Transaction_V1_Transaction.SecurityToken.SetDocument?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .setDocument(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .setDocument(v)
        }
      }()
      case 7: try {
        var v: Transaction_V1_Transaction.SecurityToken.IssueByPartition?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .issueByPartition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .issueByPartition(v)
        }
      }()
      case 8: try {
        var v: Transaction_V1_Transaction.SecurityToken.RedeemByPartition?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .redeemByPartition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .redeemByPartition(v)
        }
      }()
      case 9: try {
        var v: Transaction_V1_Transaction.SecurityToken.OperatorRedeemByPartition?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .operatorRedeemByPartition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .operatorRedeemByPartition(v)
        }
      }()
      case 10: try {
        var v: Transaction_V1_Transaction.SecurityToken.RenounceControl?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .renounceControl(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .renounceControl(v)
        }
      }()
      case 11: try {
        var v: Transaction_V1_Transaction.SecurityToken.RenounceIssuance?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .renounceIssuance(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .renounceIssuance(v)
        }
      }()
      case 12: try {
        var v: Transaction_V1_Transaction.Pausable.Pause?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .pause(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .pause(v)
        }
      }()
      case 13: try {
        var v: Transaction_V1_Transaction.Pausable.Unpause?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .unpause(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .unpause(v)
        }
      }()
      case 14: try {
        var v: Transaction_V1_Transaction.Ownable.TransferOwnership?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .transferOwnership(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .transferOwnership(v)
        }
      }()
      case 15: try {
        var v: Transaction_V1_Transaction.ERC1400Raw.AuthorizeOperator?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .authorizeOperator(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .authorizeOperator(v)
        }
      }()
      case 16: try {
        var v: Transaction_V1_Transaction.ERC1400Raw.RevokeOperator?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .revokeOperator(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .revokeOperator(v)
        }
      }()
      case 17: try {
        var v: Transaction_V1_Transaction.ERC1400Partition.TransferByPartition?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .transferByPartition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .transferByPartition(v)
        }
      }()
      case 18: try {
        var v: Transaction_V1_Transaction.ERC1400Partition.OperatorTransferByPartition?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .operatorTransferByPartition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .operatorTransferByPartition(v)
        }
      }()
      case 19: try {
        var v: Transaction_V1_Transaction.ERC1400Partition.AuthorizeOperatorByPartition?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .authorizeOperatorByPartition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .authorizeOperatorByPartition(v)
        }
      }()
      case 20: try {
        var v: Transaction_V1_Transaction.ERC1400Partition.RevokeOperatorByPartition?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .revokeOperatorByPartition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .revokeOperatorByPartition(v)
        }
      }()
      case 21: try {
        var v: Transaction_V1_Transaction.ERC1400Partition.TransferWithData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .transferWithData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .transferWithData(v)
        }
      }()
      case 22: try {
        var v: Transaction_V1_Transaction.ERC1400Partition.TransferFromWithData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .transferFromWithData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .transferFromWithData(v)
        }
      }()
      case 23: try {
        var v: Transaction_V1_Transaction.ERC1400ERC20.Transfer?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .transfer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .transfer(v)
        }
      }()
      case 24: try {
        var v: Transaction_V1_Transaction.ERC1400ERC20.Approve?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .approve(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .approve(v)
        }
      }()
      case 25: try {
        var v: Transaction_V1_Transaction.ERC1400ERC20.TransferFrom?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .transferFrom(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .transferFrom(v)
        }
      }()
      case 26: try {
        var v: Transaction_V1_Transaction.ERC1400Capped.SetCap?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .setCap(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .setCap(v)
        }
      }()
      case 27: try {
        var v: Transaction_V1_Transaction.Constrainable.SetModulesByPartition?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .setModulesByPartition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .setModulesByPartition(v)
        }
      }()
      case 28: try {
        var v: Transaction_V1_Transaction.Administrable.AddRole?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .addRole(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .addRole(v)
        }
      }()
      case 29: try {
        var v: Transaction_V1_Transaction.Administrable.BulkAddRole?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .bulkAddRole(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .bulkAddRole(v)
        }
      }()
      case 30: try {
        var v: Transaction_V1_Transaction.Administrable.RemoveRole?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .removeRole(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .removeRole(v)
        }
      }()
      case 31: try {
        var v: Transaction_V1_Transaction.Administrable.RenounceRole?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .renounceRole(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .renounceRole(v)
        }
      }()
      case 32: try {
        var v: Transaction_V1_Transaction.SpendingLimitsConstraintModule.DeploySpendingLimitsConstraintModule?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .deploySpendingLimitsConstraintModule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .deploySpendingLimitsConstraintModule(v)
        }
      }()
      case 33: try {
        var v: Transaction_V1_Transaction.SpendingLimitsConstraintModule.AddTimelock?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .addTimelock(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .addTimelock(v)
        }
      }()
      case 34: try {
        var v: Transaction_V1_Transaction.SpendingLimitsConstraintModule.SetTimelock?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .setTimelock(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .setTimelock(v)
        }
      }()
      case 35: try {
        var v: Transaction_V1_Transaction.SpendingLimitsConstraintModule.DeleteTimelock?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .deleteTimelock(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .deleteTimelock(v)
        }
      }()
      case 36: try {
        var v: Transaction_V1_Transaction.TimeLockConstraintModule.DeployTimeLockConstraintModule?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .deployTimeLockConstraintModule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .deployTimeLockConstraintModule(v)
        }
      }()
      case 37: try {
        var v: Transaction_V1_Transaction.TimeLockConstraintModule.EditAmountTimeLock?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .editAmountTimeLock(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .editAmountTimeLock(v)
        }
      }()
      case 38: try {
        var v: Transaction_V1_Transaction.TimeLockConstraintModule.EditAccountTimeLock?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .editAccountTimeLock(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .editAccountTimeLock(v)
        }
      }()
      case 39: try {
        var v: Transaction_V1_Transaction.TimeLockConstraintModule.EditTimeLock?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .editTimeLock(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .editTimeLock(v)
        }
      }()
      case 40: try {
        var v: Transaction_V1_Transaction.VestingPeriodConstraintModule.DeployVestingPeriodConstraintModule?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .deployVestingPeriodConstraintModule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .deployVestingPeriodConstraintModule(v)
        }
      }()
      case 41: try {
        var v: Transaction_V1_Transaction.VestingPeriodConstraintModule.SetVestingOptions?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .setVestingOptions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .setVestingOptions(v)
        }
      }()
      case 42: try {
        var v: Transaction_V1_Transaction.WhitelistConstraintModule.DeployWhitelistConstraintModule?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .deployWhitelistConstraintModule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .deployWhitelistConstraintModule(v)
        }
      }()
      case 43: try {
        var v: Transaction_V1_Transaction.WhitelistConstraintModule.EditWhitelist?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .editWhitelist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .editWhitelist(v)
        }
      }()
      case 44: try {
        var v: Transaction_V1_Transaction.WhitelistConstraintModule.BulkEditWhitelist?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .bulkEditWhitelist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .bulkEditWhitelist(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.contract.isEmpty {
      try visitor.visitSingularStringField(value: self.contract, fieldNumber: 2)
    }
    if self.network != 0 {
      try visitor.visitSingularUInt32Field(value: self.network, fieldNumber: 3)
    }
    switch self.data {
    case .deployNewSecurityToken?: try {
      guard case .deployNewSecurityToken(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .bulkIssueByPartition?: try {
      guard case .bulkIssueByPartition(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .setDocument?: try {
      guard case .setDocument(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .issueByPartition?: try {
      guard case .issueByPartition(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .redeemByPartition?: try {
      guard case .redeemByPartition(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .operatorRedeemByPartition?: try {
      guard case .operatorRedeemByPartition(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .renounceControl?: try {
      guard case .renounceControl(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .renounceIssuance?: try {
      guard case .renounceIssuance(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .pause?: try {
      guard case .pause(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .unpause?: try {
      guard case .unpause(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .transferOwnership?: try {
      guard case .transferOwnership(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .authorizeOperator?: try {
      guard case .authorizeOperator(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .revokeOperator?: try {
      guard case .revokeOperator(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .transferByPartition?: try {
      guard case .transferByPartition(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .operatorTransferByPartition?: try {
      guard case .operatorTransferByPartition(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .authorizeOperatorByPartition?: try {
      guard case .authorizeOperatorByPartition(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .revokeOperatorByPartition?: try {
      guard case .revokeOperatorByPartition(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .transferWithData?: try {
      guard case .transferWithData(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .transferFromWithData?: try {
      guard case .transferFromWithData(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .transfer?: try {
      guard case .transfer(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .approve?: try {
      guard case .approve(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .transferFrom?: try {
      guard case .transferFrom(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .setCap?: try {
      guard case .setCap(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case .setModulesByPartition?: try {
      guard case .setModulesByPartition(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case .addRole?: try {
      guard case .addRole(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case .bulkAddRole?: try {
      guard case .bulkAddRole(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
    }()
    case .removeRole?: try {
      guard case .removeRole(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .renounceRole?: try {
      guard case .renounceRole(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .deploySpendingLimitsConstraintModule?: try {
      guard case .deploySpendingLimitsConstraintModule(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .addTimelock?: try {
      guard case .addTimelock(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
    }()
    case .setTimelock?: try {
      guard case .setTimelock(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
    }()
    case .deleteTimelock?: try {
      guard case .deleteTimelock(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
    }()
    case .deployTimeLockConstraintModule?: try {
      guard case .deployTimeLockConstraintModule(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
    }()
    case .editAmountTimeLock?: try {
      guard case .editAmountTimeLock(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
    }()
    case .editAccountTimeLock?: try {
      guard case .editAccountTimeLock(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
    }()
    case .editTimeLock?: try {
      guard case .editTimeLock(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
    }()
    case .deployVestingPeriodConstraintModule?: try {
      guard case .deployVestingPeriodConstraintModule(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
    }()
    case .setVestingOptions?: try {
      guard case .setVestingOptions(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
    }()
    case .deployWhitelistConstraintModule?: try {
      guard case .deployWhitelistConstraintModule(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
    }()
    case .editWhitelist?: try {
      guard case .editWhitelist(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
    }()
    case .bulkEditWhitelist?: try {
      guard case .bulkEditWhitelist(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction, rhs: Transaction_V1_Transaction) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs.contract != rhs.contract {return false}
    if lhs.network != rhs.network {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.SecurityTokenFactory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.protoMessageName + ".SecurityTokenFactory"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.SecurityTokenFactory, rhs: Transaction_V1_Transaction.SecurityTokenFactory) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.SecurityTokenFactory.DeployNewSecurityToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.SecurityTokenFactory.protoMessageName + ".DeployNewSecurityToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "symbol"),
    3: .same(proto: "granularity"),
    4: .same(proto: "cap"),
    5: .same(proto: "admin"),
    6: .same(proto: "controller"),
    7: .same(proto: "issuer"),
    8: .same(proto: "redeemer"),
    9: .standard(proto: "module_editor"),
    10: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.granularity) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.cap) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.admin) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.controller) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.issuer) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.redeemer) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.moduleEditor) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 2)
    }
    if self.granularity != 0 {
      try visitor.visitSingularUInt64Field(value: self.granularity, fieldNumber: 3)
    }
    if self.cap != 0 {
      try visitor.visitSingularUInt64Field(value: self.cap, fieldNumber: 4)
    }
    if !self.admin.isEmpty {
      try visitor.visitSingularStringField(value: self.admin, fieldNumber: 5)
    }
    if !self.controller.isEmpty {
      try visitor.visitSingularStringField(value: self.controller, fieldNumber: 6)
    }
    if !self.issuer.isEmpty {
      try visitor.visitSingularStringField(value: self.issuer, fieldNumber: 7)
    }
    if !self.redeemer.isEmpty {
      try visitor.visitSingularStringField(value: self.redeemer, fieldNumber: 8)
    }
    if !self.moduleEditor.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleEditor, fieldNumber: 9)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.SecurityTokenFactory.DeployNewSecurityToken, rhs: Transaction_V1_Transaction.SecurityTokenFactory.DeployNewSecurityToken) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.granularity != rhs.granularity {return false}
    if lhs.cap != rhs.cap {return false}
    if lhs.admin != rhs.admin {return false}
    if lhs.controller != rhs.controller {return false}
    if lhs.issuer != rhs.issuer {return false}
    if lhs.redeemer != rhs.redeemer {return false}
    if lhs.moduleEditor != rhs.moduleEditor {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.SecurityToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.protoMessageName + ".SecurityToken"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.SecurityToken, rhs: Transaction_V1_Transaction.SecurityToken) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.SecurityToken.BulkIssueByPartition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.SecurityToken.protoMessageName + ".BulkIssueByPartition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "partition"),
    2: .standard(proto: "token_holders"),
    3: .same(proto: "values"),
    4: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.partition) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.tokenHolders) }()
      case 3: try { try decoder.decodeRepeatedUInt64Field(value: &self.values) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.partition.isEmpty {
      try visitor.visitSingularBytesField(value: self.partition, fieldNumber: 1)
    }
    if !self.tokenHolders.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tokenHolders, fieldNumber: 2)
    }
    if !self.values.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.values, fieldNumber: 3)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.SecurityToken.BulkIssueByPartition, rhs: Transaction_V1_Transaction.SecurityToken.BulkIssueByPartition) -> Bool {
    if lhs.partition != rhs.partition {return false}
    if lhs.tokenHolders != rhs.tokenHolders {return false}
    if lhs.values != rhs.values {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.SecurityToken.SetDocument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.SecurityToken.protoMessageName + ".SetDocument"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "document_name"),
    2: .same(proto: "uri"),
    3: .standard(proto: "document_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.documentName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.documentHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.documentName.isEmpty {
      try visitor.visitSingularBytesField(value: self.documentName, fieldNumber: 1)
    }
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 2)
    }
    if !self.documentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.documentHash, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.SecurityToken.SetDocument, rhs: Transaction_V1_Transaction.SecurityToken.SetDocument) -> Bool {
    if lhs.documentName != rhs.documentName {return false}
    if lhs.uri != rhs.uri {return false}
    if lhs.documentHash != rhs.documentHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.SecurityToken.IssueByPartition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.SecurityToken.protoMessageName + ".IssueByPartition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "partition"),
    2: .same(proto: "recipient"),
    3: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.partition) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.recipient) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.partition.isEmpty {
      try visitor.visitSingularBytesField(value: self.partition, fieldNumber: 1)
    }
    if !self.recipient.isEmpty {
      try visitor.visitSingularStringField(value: self.recipient, fieldNumber: 2)
    }
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.SecurityToken.IssueByPartition, rhs: Transaction_V1_Transaction.SecurityToken.IssueByPartition) -> Bool {
    if lhs.partition != rhs.partition {return false}
    if lhs.recipient != rhs.recipient {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.SecurityToken.RedeemByPartition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.SecurityToken.protoMessageName + ".RedeemByPartition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "partition"),
    2: .same(proto: "value"),
    3: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.partition) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.partition.isEmpty {
      try visitor.visitSingularBytesField(value: self.partition, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.SecurityToken.RedeemByPartition, rhs: Transaction_V1_Transaction.SecurityToken.RedeemByPartition) -> Bool {
    if lhs.partition != rhs.partition {return false}
    if lhs.value != rhs.value {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.SecurityToken.OperatorRedeemByPartition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.SecurityToken.protoMessageName + ".OperatorRedeemByPartition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "partition"),
    2: .standard(proto: "token_holder"),
    3: .same(proto: "value"),
    4: .same(proto: "data"),
    5: .standard(proto: "operator_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.partition) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tokenHolder) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.operatorData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.partition.isEmpty {
      try visitor.visitSingularBytesField(value: self.partition, fieldNumber: 1)
    }
    if !self.tokenHolder.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenHolder, fieldNumber: 2)
    }
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 3)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 4)
    }
    if !self.operatorData.isEmpty {
      try visitor.visitSingularBytesField(value: self.operatorData, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.SecurityToken.OperatorRedeemByPartition, rhs: Transaction_V1_Transaction.SecurityToken.OperatorRedeemByPartition) -> Bool {
    if lhs.partition != rhs.partition {return false}
    if lhs.tokenHolder != rhs.tokenHolder {return false}
    if lhs.value != rhs.value {return false}
    if lhs.data != rhs.data {return false}
    if lhs.operatorData != rhs.operatorData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.SecurityToken.RenounceControl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.SecurityToken.protoMessageName + ".RenounceControl"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.SecurityToken.RenounceControl, rhs: Transaction_V1_Transaction.SecurityToken.RenounceControl) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.SecurityToken.RenounceIssuance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.SecurityToken.protoMessageName + ".RenounceIssuance"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.SecurityToken.RenounceIssuance, rhs: Transaction_V1_Transaction.SecurityToken.RenounceIssuance) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.Pausable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.protoMessageName + ".Pausable"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.Pausable, rhs: Transaction_V1_Transaction.Pausable) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.Pausable.Pause: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.Pausable.protoMessageName + ".Pause"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.Pausable.Pause, rhs: Transaction_V1_Transaction.Pausable.Pause) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.Pausable.Unpause: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.Pausable.protoMessageName + ".Unpause"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.Pausable.Unpause, rhs: Transaction_V1_Transaction.Pausable.Unpause) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.Ownable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.protoMessageName + ".Ownable"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.Ownable, rhs: Transaction_V1_Transaction.Ownable) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.Ownable.TransferOwnership: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.Ownable.protoMessageName + ".TransferOwnership"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "new_owner"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.newOwner) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.newOwner.isEmpty {
      try visitor.visitSingularStringField(value: self.newOwner, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.Ownable.TransferOwnership, rhs: Transaction_V1_Transaction.Ownable.TransferOwnership) -> Bool {
    if lhs.newOwner != rhs.newOwner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.ERC1400Raw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.protoMessageName + ".ERC1400Raw"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.ERC1400Raw, rhs: Transaction_V1_Transaction.ERC1400Raw) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.ERC1400Raw.AuthorizeOperator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.ERC1400Raw.protoMessageName + ".AuthorizeOperator"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.`operator`) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.`operator`.isEmpty {
      try visitor.visitSingularStringField(value: self.`operator`, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.ERC1400Raw.AuthorizeOperator, rhs: Transaction_V1_Transaction.ERC1400Raw.AuthorizeOperator) -> Bool {
    if lhs.`operator` != rhs.`operator` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.ERC1400Raw.RevokeOperator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.ERC1400Raw.protoMessageName + ".RevokeOperator"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.`operator`) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.`operator`.isEmpty {
      try visitor.visitSingularStringField(value: self.`operator`, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.ERC1400Raw.RevokeOperator, rhs: Transaction_V1_Transaction.ERC1400Raw.RevokeOperator) -> Bool {
    if lhs.`operator` != rhs.`operator` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.ERC1400Partition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.protoMessageName + ".ERC1400Partition"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.ERC1400Partition, rhs: Transaction_V1_Transaction.ERC1400Partition) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.ERC1400Partition.TransferByPartition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.ERC1400Partition.protoMessageName + ".TransferByPartition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "partition"),
    2: .same(proto: "to"),
    3: .same(proto: "value"),
    4: .same(proto: "calldata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.partition) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.to) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.calldata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.partition.isEmpty {
      try visitor.visitSingularBytesField(value: self.partition, fieldNumber: 1)
    }
    if !self.to.isEmpty {
      try visitor.visitSingularStringField(value: self.to, fieldNumber: 2)
    }
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 3)
    }
    if !self.calldata.isEmpty {
      try visitor.visitSingularBytesField(value: self.calldata, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.ERC1400Partition.TransferByPartition, rhs: Transaction_V1_Transaction.ERC1400Partition.TransferByPartition) -> Bool {
    if lhs.partition != rhs.partition {return false}
    if lhs.to != rhs.to {return false}
    if lhs.value != rhs.value {return false}
    if lhs.calldata != rhs.calldata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.ERC1400Partition.OperatorTransferByPartition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.ERC1400Partition.protoMessageName + ".OperatorTransferByPartition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "partition"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
    4: .same(proto: "value"),
    5: .same(proto: "data"),
    6: .standard(proto: "operator_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.partition) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.from) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.to) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.operatorData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.partition.isEmpty {
      try visitor.visitSingularBytesField(value: self.partition, fieldNumber: 1)
    }
    if !self.from.isEmpty {
      try visitor.visitSingularStringField(value: self.from, fieldNumber: 2)
    }
    if !self.to.isEmpty {
      try visitor.visitSingularStringField(value: self.to, fieldNumber: 3)
    }
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 4)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 5)
    }
    if !self.operatorData.isEmpty {
      try visitor.visitSingularBytesField(value: self.operatorData, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.ERC1400Partition.OperatorTransferByPartition, rhs: Transaction_V1_Transaction.ERC1400Partition.OperatorTransferByPartition) -> Bool {
    if lhs.partition != rhs.partition {return false}
    if lhs.from != rhs.from {return false}
    if lhs.to != rhs.to {return false}
    if lhs.value != rhs.value {return false}
    if lhs.data != rhs.data {return false}
    if lhs.operatorData != rhs.operatorData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.ERC1400Partition.AuthorizeOperatorByPartition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.ERC1400Partition.protoMessageName + ".AuthorizeOperatorByPartition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "partition"),
    2: .same(proto: "operator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.partition) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.`operator`) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.partition.isEmpty {
      try visitor.visitSingularBytesField(value: self.partition, fieldNumber: 1)
    }
    if !self.`operator`.isEmpty {
      try visitor.visitSingularStringField(value: self.`operator`, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.ERC1400Partition.AuthorizeOperatorByPartition, rhs: Transaction_V1_Transaction.ERC1400Partition.AuthorizeOperatorByPartition) -> Bool {
    if lhs.partition != rhs.partition {return false}
    if lhs.`operator` != rhs.`operator` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.ERC1400Partition.RevokeOperatorByPartition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.ERC1400Partition.protoMessageName + ".RevokeOperatorByPartition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "partition"),
    2: .same(proto: "operator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.partition) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.`operator`) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.partition.isEmpty {
      try visitor.visitSingularBytesField(value: self.partition, fieldNumber: 1)
    }
    if !self.`operator`.isEmpty {
      try visitor.visitSingularStringField(value: self.`operator`, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.ERC1400Partition.RevokeOperatorByPartition, rhs: Transaction_V1_Transaction.ERC1400Partition.RevokeOperatorByPartition) -> Bool {
    if lhs.partition != rhs.partition {return false}
    if lhs.`operator` != rhs.`operator` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.ERC1400Partition.TransferWithData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.ERC1400Partition.protoMessageName + ".TransferWithData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "to"),
    2: .same(proto: "value"),
    3: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.to) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.to.isEmpty {
      try visitor.visitSingularStringField(value: self.to, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.ERC1400Partition.TransferWithData, rhs: Transaction_V1_Transaction.ERC1400Partition.TransferWithData) -> Bool {
    if lhs.to != rhs.to {return false}
    if lhs.value != rhs.value {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.ERC1400Partition.TransferFromWithData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.ERC1400Partition.protoMessageName + ".TransferFromWithData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "to"),
    3: .same(proto: "value"),
    4: .same(proto: "data"),
    5: .standard(proto: "operator_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.from) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.to) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.operatorData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.from.isEmpty {
      try visitor.visitSingularStringField(value: self.from, fieldNumber: 1)
    }
    if !self.to.isEmpty {
      try visitor.visitSingularStringField(value: self.to, fieldNumber: 2)
    }
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 3)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 4)
    }
    if !self.operatorData.isEmpty {
      try visitor.visitSingularBytesField(value: self.operatorData, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.ERC1400Partition.TransferFromWithData, rhs: Transaction_V1_Transaction.ERC1400Partition.TransferFromWithData) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.to != rhs.to {return false}
    if lhs.value != rhs.value {return false}
    if lhs.data != rhs.data {return false}
    if lhs.operatorData != rhs.operatorData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.ERC1400ERC20: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.protoMessageName + ".ERC1400ERC20"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.ERC1400ERC20, rhs: Transaction_V1_Transaction.ERC1400ERC20) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.ERC1400ERC20.Transfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.ERC1400ERC20.protoMessageName + ".Transfer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "to"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.to) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.to.isEmpty {
      try visitor.visitSingularStringField(value: self.to, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.ERC1400ERC20.Transfer, rhs: Transaction_V1_Transaction.ERC1400ERC20.Transfer) -> Bool {
    if lhs.to != rhs.to {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.ERC1400ERC20.Approve: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.ERC1400ERC20.protoMessageName + ".Approve"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "spender"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.spender) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.spender.isEmpty {
      try visitor.visitSingularStringField(value: self.spender, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.ERC1400ERC20.Approve, rhs: Transaction_V1_Transaction.ERC1400ERC20.Approve) -> Bool {
    if lhs.spender != rhs.spender {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.ERC1400ERC20.TransferFrom: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.ERC1400ERC20.protoMessageName + ".TransferFrom"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "to"),
    3: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.from) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.to) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.from.isEmpty {
      try visitor.visitSingularStringField(value: self.from, fieldNumber: 1)
    }
    if !self.to.isEmpty {
      try visitor.visitSingularStringField(value: self.to, fieldNumber: 2)
    }
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.ERC1400ERC20.TransferFrom, rhs: Transaction_V1_Transaction.ERC1400ERC20.TransferFrom) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.to != rhs.to {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.ERC1400Capped: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.protoMessageName + ".ERC1400Capped"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.ERC1400Capped, rhs: Transaction_V1_Transaction.ERC1400Capped) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.ERC1400Capped.SetCap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.ERC1400Capped.protoMessageName + ".SetCap"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "new_cap"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.newCap) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.newCap != 0 {
      try visitor.visitSingularUInt64Field(value: self.newCap, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.ERC1400Capped.SetCap, rhs: Transaction_V1_Transaction.ERC1400Capped.SetCap) -> Bool {
    if lhs.newCap != rhs.newCap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.Constrainable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.protoMessageName + ".Constrainable"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.Constrainable, rhs: Transaction_V1_Transaction.Constrainable) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.Constrainable.SetModulesByPartition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.Constrainable.protoMessageName + ".SetModulesByPartition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "partition"),
    2: .standard(proto: "new_modules"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.partition) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.newModules) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.partition.isEmpty {
      try visitor.visitSingularBytesField(value: self.partition, fieldNumber: 1)
    }
    if !self.newModules.isEmpty {
      try visitor.visitRepeatedStringField(value: self.newModules, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.Constrainable.SetModulesByPartition, rhs: Transaction_V1_Transaction.Constrainable.SetModulesByPartition) -> Bool {
    if lhs.partition != rhs.partition {return false}
    if lhs.newModules != rhs.newModules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.Administrable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.protoMessageName + ".Administrable"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.Administrable, rhs: Transaction_V1_Transaction.Administrable) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.Administrable.AddRole: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.Administrable.protoMessageName + ".AddRole"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "role"),
    2: .same(proto: "account"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.role) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.account) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.role.isEmpty {
      try visitor.visitSingularBytesField(value: self.role, fieldNumber: 1)
    }
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.Administrable.AddRole, rhs: Transaction_V1_Transaction.Administrable.AddRole) -> Bool {
    if lhs.role != rhs.role {return false}
    if lhs.account != rhs.account {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.Administrable.BulkAddRole: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.Administrable.protoMessageName + ".BulkAddRole"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "roles"),
    2: .same(proto: "accounts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.roles) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.accounts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roles.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.roles, fieldNumber: 1)
    }
    if !self.accounts.isEmpty {
      try visitor.visitRepeatedStringField(value: self.accounts, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.Administrable.BulkAddRole, rhs: Transaction_V1_Transaction.Administrable.BulkAddRole) -> Bool {
    if lhs.roles != rhs.roles {return false}
    if lhs.accounts != rhs.accounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.Administrable.RemoveRole: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.Administrable.protoMessageName + ".RemoveRole"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "role"),
    2: .same(proto: "account"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.role) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.account) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.role.isEmpty {
      try visitor.visitSingularBytesField(value: self.role, fieldNumber: 1)
    }
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.Administrable.RemoveRole, rhs: Transaction_V1_Transaction.Administrable.RemoveRole) -> Bool {
    if lhs.role != rhs.role {return false}
    if lhs.account != rhs.account {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.Administrable.RenounceRole: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.Administrable.protoMessageName + ".RenounceRole"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "role"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.role) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.role.isEmpty {
      try visitor.visitSingularBytesField(value: self.role, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.Administrable.RenounceRole, rhs: Transaction_V1_Transaction.Administrable.RenounceRole) -> Bool {
    if lhs.role != rhs.role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.SpendingLimitsConstraintModule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.protoMessageName + ".SpendingLimitsConstraintModule"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.SpendingLimitsConstraintModule, rhs: Transaction_V1_Transaction.SpendingLimitsConstraintModule) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.SpendingLimitsConstraintModule.DeploySpendingLimitsConstraintModule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.SpendingLimitsConstraintModule.protoMessageName + ".DeploySpendingLimitsConstraintModule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tokenAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokenAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.SpendingLimitsConstraintModule.DeploySpendingLimitsConstraintModule, rhs: Transaction_V1_Transaction.SpendingLimitsConstraintModule.DeploySpendingLimitsConstraintModule) -> Bool {
    if lhs.tokenAddress != rhs.tokenAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.SpendingLimitsConstraintModule.AddTimelock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.SpendingLimitsConstraintModule.protoMessageName + ".AddTimelock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "period_length"),
    2: .standard(proto: "amount_allowed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._periodLength) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.amountAllowed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._periodLength {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.amountAllowed != 0 {
      try visitor.visitSingularUInt64Field(value: self.amountAllowed, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.SpendingLimitsConstraintModule.AddTimelock, rhs: Transaction_V1_Transaction.SpendingLimitsConstraintModule.AddTimelock) -> Bool {
    if lhs._periodLength != rhs._periodLength {return false}
    if lhs.amountAllowed != rhs.amountAllowed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.SpendingLimitsConstraintModule.SetTimelock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.SpendingLimitsConstraintModule.protoMessageName + ".SetTimelock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .standard(proto: "period_length"),
    3: .standard(proto: "amount_allowed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._periodLength) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.amountAllowed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.index != 0 {
      try visitor.visitSingularUInt64Field(value: self.index, fieldNumber: 1)
    }
    try { if let v = self._periodLength {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.amountAllowed != 0 {
      try visitor.visitSingularUInt64Field(value: self.amountAllowed, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.SpendingLimitsConstraintModule.SetTimelock, rhs: Transaction_V1_Transaction.SpendingLimitsConstraintModule.SetTimelock) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs._periodLength != rhs._periodLength {return false}
    if lhs.amountAllowed != rhs.amountAllowed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.SpendingLimitsConstraintModule.DeleteTimelock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.SpendingLimitsConstraintModule.protoMessageName + ".DeleteTimelock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularUInt64Field(value: self.index, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.SpendingLimitsConstraintModule.DeleteTimelock, rhs: Transaction_V1_Transaction.SpendingLimitsConstraintModule.DeleteTimelock) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.TimeLockConstraintModule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.protoMessageName + ".TimeLockConstraintModule"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.TimeLockConstraintModule, rhs: Transaction_V1_Transaction.TimeLockConstraintModule) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.TimeLockConstraintModule.DeployTimeLockConstraintModule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.TimeLockConstraintModule.protoMessageName + ".DeployTimeLockConstraintModule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tokenAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokenAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.TimeLockConstraintModule.DeployTimeLockConstraintModule, rhs: Transaction_V1_Transaction.TimeLockConstraintModule.DeployTimeLockConstraintModule) -> Bool {
    if lhs.tokenAddress != rhs.tokenAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.TimeLockConstraintModule.EditAmountTimeLock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.TimeLockConstraintModule.protoMessageName + ".EditAmountTimeLock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "time"),
    3: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.TimeLockConstraintModule.EditAmountTimeLock, rhs: Transaction_V1_Transaction.TimeLockConstraintModule.EditAmountTimeLock) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs._time != rhs._time {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.TimeLockConstraintModule.EditAccountTimeLock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.TimeLockConstraintModule.protoMessageName + ".EditAccountTimeLock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.TimeLockConstraintModule.EditAccountTimeLock, rhs: Transaction_V1_Transaction.TimeLockConstraintModule.EditAccountTimeLock) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs._time != rhs._time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.TimeLockConstraintModule.EditTimeLock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.TimeLockConstraintModule.protoMessageName + ".EditTimeLock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.TimeLockConstraintModule.EditTimeLock, rhs: Transaction_V1_Transaction.TimeLockConstraintModule.EditTimeLock) -> Bool {
    if lhs._time != rhs._time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.VestingPeriodConstraintModule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.protoMessageName + ".VestingPeriodConstraintModule"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.VestingPeriodConstraintModule, rhs: Transaction_V1_Transaction.VestingPeriodConstraintModule) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.VestingPeriodConstraintModule.DeployVestingPeriodConstraintModule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.VestingPeriodConstraintModule.protoMessageName + ".DeployVestingPeriodConstraintModule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tokenAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokenAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.VestingPeriodConstraintModule.DeployVestingPeriodConstraintModule, rhs: Transaction_V1_Transaction.VestingPeriodConstraintModule.DeployVestingPeriodConstraintModule) -> Bool {
    if lhs.tokenAddress != rhs.tokenAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.VestingPeriodConstraintModule.SetVestingOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.VestingPeriodConstraintModule.protoMessageName + ".SetVestingOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vesting_start"),
    2: .standard(proto: "vested_fraction_after_start"),
    3: .standard(proto: "vesting_ratio"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._vestingStart) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.vestedFractionAfterStart) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.vestingRatio) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._vestingStart {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.vestedFractionAfterStart != 0 {
      try visitor.visitSingularUInt64Field(value: self.vestedFractionAfterStart, fieldNumber: 2)
    }
    if self.vestingRatio != 0 {
      try visitor.visitSingularUInt64Field(value: self.vestingRatio, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.VestingPeriodConstraintModule.SetVestingOptions, rhs: Transaction_V1_Transaction.VestingPeriodConstraintModule.SetVestingOptions) -> Bool {
    if lhs._vestingStart != rhs._vestingStart {return false}
    if lhs.vestedFractionAfterStart != rhs.vestedFractionAfterStart {return false}
    if lhs.vestingRatio != rhs.vestingRatio {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.WhitelistConstraintModule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.protoMessageName + ".WhitelistConstraintModule"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.WhitelistConstraintModule, rhs: Transaction_V1_Transaction.WhitelistConstraintModule) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.WhitelistConstraintModule.DeployWhitelistConstraintModule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.WhitelistConstraintModule.protoMessageName + ".DeployWhitelistConstraintModule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tokenAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokenAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.WhitelistConstraintModule.DeployWhitelistConstraintModule, rhs: Transaction_V1_Transaction.WhitelistConstraintModule.DeployWhitelistConstraintModule) -> Bool {
    if lhs.tokenAddress != rhs.tokenAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.WhitelistConstraintModule.EditWhitelist: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.WhitelistConstraintModule.protoMessageName + ".EditWhitelist"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "whitelisted"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.whitelisted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    if self.whitelisted != false {
      try visitor.visitSingularBoolField(value: self.whitelisted, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.WhitelistConstraintModule.EditWhitelist, rhs: Transaction_V1_Transaction.WhitelistConstraintModule.EditWhitelist) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.whitelisted != rhs.whitelisted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.WhitelistConstraintModule.BulkEditWhitelist: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.WhitelistConstraintModule.protoMessageName + ".BulkEditWhitelist"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accounts"),
    2: .same(proto: "whitelisted"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.accounts) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.whitelisted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accounts.isEmpty {
      try visitor.visitRepeatedStringField(value: self.accounts, fieldNumber: 1)
    }
    if self.whitelisted != false {
      try visitor.visitSingularBoolField(value: self.whitelisted, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.WhitelistConstraintModule.BulkEditWhitelist, rhs: Transaction_V1_Transaction.WhitelistConstraintModule.BulkEditWhitelist) -> Bool {
    if lhs.accounts != rhs.accounts {return false}
    if lhs.whitelisted != rhs.whitelisted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_V1_Transaction.Metadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Transaction_V1_Transaction.protoMessageName + ".Metadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "date"),
    3: .same(proto: "reverted"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reverted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 1)
    }
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.reverted.isEmpty {
      try visitor.visitSingularStringField(value: self.reverted, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_V1_Transaction.Metadata, rhs: Transaction_V1_Transaction.Metadata) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs._date != rhs._date {return false}
    if lhs.reverted != rhs.reverted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
